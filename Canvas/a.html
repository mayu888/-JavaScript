<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
      }
      canvas {
        border: 1px solid red;
        margin: 30px;
      }
    </style>
  </head>
  <canvas width="1080" height="300"></canvas>
  <body>
    <script>
      draw();
      function draw() {
        const canvas = document.querySelector("canvas");
        if (!canvas.getContext) return;
        const ctx = canvas.getContext("2d");
      }
      draw();
      function draw() {
        const canvas = document.querySelector("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        /*
          填充
         ctx.fillStyle='rgb(200,0,0)' // 添加颜色
         ctx.fillRect(10,10,300,350) // fillRect(x轴，y轴，width，height) 画完了不能添加颜色

         ctx.fillStyle='blue'
         ctx.fillRect(30,30,350,350)
        */

        /*
        描边
        ctx.strokeStyle='rgb(200,0,0)'
        ctx.strokeRect(10,10,300,350)

        ctx.strokeStyle='blue'
        ctx.strokeRect(30,30,350,350)
        */

        /*
          清除指定矩形
          ctx.fillRect(25,25,100,100)
          ctx.clearRect(45,45,60,60)  //清除指定区域的矩形
          ctx.strokeRect(50,50,50,50)
        */
        // 以上三种方法都是如何通过路径绘制矩形

        /*
          图形的基本元素就是路径
          1.首先创建起始点
          2.使用画图命令画出路径，
          3.把路径闭合
          4.通过描边或填充绘制图形
        */

        /*
              // 绘制一个等腰三角形
              ctx.beginPath();
              ctx.moveTo(50, 50); //起始点 x轴75 y轴50
              ctx.lineTo(100, 100); //二点 x轴100  y轴125
              ctx.lineTo(50, 100); //三点 x轴75  y轴125
              ctx.fill(); //填充

              // 绘制一个等边三角形
              ctx.beginPath();
              ctx.moveTo(150, 150);
              ctx.lineTo(175, 193.3);
              ctx.lineTo(125, 193.3);
              ctx.lineTo(150, 150); //回到起始点，若不回到起始点，其实三角形并没有画完，而填充看不到缺失的那条线
              // 或者使用 ctx.closePath() 从结尾位置连接到起始位置，相当于闭合
              ctx.stroke();
              */
        /*
          圆的组成：圆心（x,y） 半径 开始角度 结束角度  顺时针 逆时针
        */
        /*
        ctx.strokeStyle='origin'
        ctx.lineWidth=10;  //画笔的宽度
                             //3点钟方向            //默认false 顺时针
        // ctx.arc(x,y,radius,startAngle,endAngle ,顺时针逆时针（boolean))
      // ctx.arc(400,300,150,0,Math.PI)  //半圆
      ctx.arc(400,300,150,0,Math.PI*2)  //圆
        ctx.stroke()
      */

        /*
        循环建圆
        let x=20;
        let y=20;
        let radius=20;
        let startAngle=0;
        let angle=Math.PI;

        for(let i = 0;i<4;i++){
          for(let j=0;j<3;j++){
            ctx.beginPath()
            x=x+j*100
            y=y+i*00
            angle=Math.PI+(Math.PI*j)/2
            let angleclose=(i%2)===0?false:true
            ctx.arc(x,y,radius,startAngle,angle,angleclose)
            ctx.stroke()
          }
        }
      */

        /*
        画笑脸

          ctx.beginPath()
        ctx.lineWidth=5;
        ctx.arc(200,200,100,0,Math.PI*2)
        ctx.stroke()

        ctx.beginPath()
        ctx.arc(160,160,10,0,Math.PI*2)
        ctx.stroke()

        ctx.beginPath()
        ctx.arc(230,160,10,0,Math.PI*2)
        ctx.stroke()

        ctx.beginPath()
        ctx.arc(200,200,60,0,Math.PI)
        ctx.stroke()

      */

        /*
       线性渐变
       参数1 起点x1
       参数2 起点y1
       参数3 终点x2
       参数4 终点y2
       const ling=ctx.createLinearGradient(0,0,0,150) //计算位置从画布的起点开始算
      参数1 0-1之间的数值，表示颜色所在的相对位置
      参数2 颜色
      ling.addColorStop(0,'red')
      ling.addColorStop(0.5,'blue')
      ling.addColorStop(0.6,'yellow')
      ctx.fillStyle=ling;
      ctx.fillRect(10,10,150,50)
      */

        /*
       绘制图片
       绘制图片时一定要保证图片渲染完成 所以绘制图片的操作放在onload函数里

      const img=new Image()
      img.src='https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1601557500271&di=f8de19d1eed86a969668f1983b4576d6&imgtype=0&src=http%3A%2F%2Fattach.bbs.miui.com%2Fforum%2F201303%2F18%2F233119quyrec7to3ws3rco.jpg';
      img.onload=(e)=>{
      const ptr=ctx.createPattern(e.target,'repeat')
      ctx.fillStyle=ptr
      ctx.fillRect(0,0,400,400)
      }
      */

        /*
        绘制文字阴影
      const ling=ctx.createLinearGradient(0,0,0,150)
      ling.addColorStop(0,'red')
      ling.addColorStop(0.5,'blue')
      ling.addColorStop(0.6,'yellow')
      ctx.font='500 italic 300px arial'  //font-weight font-style  font-size font-family
      ctx.shadowColor='blue'  //阴影颜色
      ctx.shadowBlur=10 //阴影模糊度
      ctx.shadowOffsetX=10 //阴影x偏移量
      ctx.shadowOffsetY=20  // 阴影y偏移量
      ctx.fillStyle=ling;
      ctx.fillText('马玉',100,300)  //内容  x轴  y轴
      */

        /*
      drawImage:图片、x轴、y轴、图片宽度、图片高度
      参数6 绘制的x轴
      参数7 绘制的y轴
      8 绘制的宽度
      9 绘制的高度

      const img=new Image();
      const img1=new Image();
      img1.src='./c2fdfc039245d688ecfc53d9f6d40d19d31b24ea.jpeg'
      img.src='https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1601557500271&di=f8de19d1eed86a969668f1983b4576d6&imgtype=0&src=http%3A%2F%2Fattach.bbs.miui.com%2Fforum%2F201303%2F18%2F233119quyrec7to3ws3rco.jpg';
      img.onload=(e)=>{
        ctx.drawImage(e.target,0,0,300,600)
      }
      img1.onload=(e)=>{
        ctx.drawImage(e.target,100,100,300,600)
      }
      */

        /*
        涂鸦
          canvas.onmousedown = (e) => {
            const offsetLeft = e.target.offsetLeft;
            const offsetTop = e.target.offsetTop;
            ctx.strokeStyle = "green";
            ctx.lineWidth = 10;
            ctx.beginPath();
            // ctx.moveTo(x,y)
            console.log();
            canvas.onmousemove = (e) => {
              const x = e.clientX - offsetLeft;
              const y = e.clientY - offsetTop;
              ctx.lineTo(x, y);
              ctx.stroke();
            };
          };
          canvas.onmouseup = () => {
            // canvas.onmousedown=null;
            canvas.onmousemove = null;
          };
      */

        /*
      刮刮卡
      */

        /*
         *  直线运动
         *  1. 画图像
         *  2. 清除图像
         *  3. 改变位置
         *  4. 画图像
         *  5. 2->3->4
         */
        /*
        function yundong() {
          let x = 0,
            y = 0,
            width = 50,
            height = 50,
            color = "red",
            speedX = 2,
            speedY = 2;
          ctx.fillStyle = color;
          ctx.fillRect(x, y, width, height);
          setInterval(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            x = x + speedX;
            y = y + speedY;
            if (x > canvas.width - width) {
              speedX *= -1;
            } else if (x < 0) {
              speedX *= -1;
            }
            if (y > canvas.height - height) {
              speedY *= -1;
            } else if (y < 0) {
              speedY *= -1;
            }
            ctx.fillRect(x, y, width, height);
          }, 10);
        }
        yundong();
        */

        /*
         *  水平背景移动
         *
         *
         *
         */
        let x = 0;
        const img = new Image();
        img.src = "./全景图.jpg";
        img.onload = (e) => {
          imgMove(e.target);
        };
        const imgMove = () => {
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.translate(-x, 0);
          ctx.drawImage(img, 0, 0);
          ctx.drawImage(img, canvas.width - 5, 0);
          x++;
          if (x > canvas.width) {
            x = 0;
          }
          ctx.restore();
          requestAnimationFrame(imgMove);
        };
      }
    </script>
  </body>
</html>
