
**一般编程语言在代码的执行前会经历三个步骤**
1. 分词/词法分析  
	  这个过程会将代码块分成有意义的词法单元。比如var a=1，会被分解成var、a、=、1  
2. 解析/语法分析  
	  这个过程将词法单元留（数组）转换成一个由元素逐级嵌套所组成的代表了程序的语法的结构的树，也就是AST抽象语法树
3. 代码生成  
	  将AST转换成可执行代码的过程称为代码生成，一般与语言、平台息息相关。简单来说就是将var a=1的AST转换为一组机器指令，用来 创建一个叫a的变量（包括分配内存），并将1这个值储存在a中。  

**编译器、引擎和作用域之间的关系.  
以 var a=1 这段代码为例：
		编译器在编译到var a这部分时，会询问作用域是否有一个a已经存在于当前作用域，如果存在则跳过这一段的编译继续向下执行，若不存在则会要求当前作用域声明一个新的变量，命名为a。
    接下来编译器会为引擎生成运行时所需要的代码，这些代码主要是处理a=1这个操作。在引擎运行时，会先询问当前作用域是否有一个叫做a的变量，如果有，引擎就会使用这个变量并赋值为1，如果没有则会继续向上一层作用域查找，查找到后同样会赋值为1。最后若没有找到这个变量a，引擎就会抛出一个错误。

**LHS与RSH**  
LSH：查找到某个变量，并为之进行赋值。
RSH：查找某个变量的源值并将这个值赋给需要的变量。
例：

```js
const a=1;
console.log(a)
```
上边这段代码，先找到a这个变量，并将之赋值为1--LHS查询。紧接着去查找a这个变量的源值，找到是1--RHS查询。继续查找console这个对象，然后找log方法，找到后将RHS查询后得到的值赋值这个方法--LHS查询。
LHS和RSH查找的过程都是按照作用域层层查找，直到查找到全局作用域才会停止。
RHS查询不到会抛出一个ReferenceError异常；RHS查询到但是对查询到的结果进行错误操作会抛出TypeError异常，例如对字符串进行函数执行操作。
LHS查询若是没有查找到该变量，在非严格模式下会自动创建一个全局变量，例如： function ex(){a=1};console.log(a) //1
严格模式下不会创建并且同样返回ReferenceError异常。

### this全面解析
1. 默认绑定：函数独立调用,
```js
function fn(){
	console.log(this) //window
}

'use strict'
function fn(){
	console.log(this) //undefined
}
```

2. 隐式绑定：调用位置是否有上下文对象，或者说函数有没有被包裹
```js
function fn(){
	console.log(this) //obj
}
const obj={
	fn:fn
}
obj.fn()
但要注意隐式丢失问题,虽然foo是obj的一个引用，但是它引用的是fn本身，所以调用时是fn是一个不带任何修饰的函数，所以此处为默认绑定
function fn(){
	console.log(this)
}
const obj={
	fn:fn
}
const foo=obj.fn
foo()
```
3. 显式绑定：若不想在对象内部包裹函数，而是在某个对象上强制调用函数
Object.prototype.call和Object.prototype.apply就可以解决这个问题
call和apply第一个参数若为一个原始值，在内部会被new处理，new String、new Boolean...**
call和apply本身除了第二个参数形式不一样没有任何区别
```js
function fn(){
	console.log(this)
}
const obj1={
  fn:fn
}
const obj2={}
obj.fn.call(obj2) || obj.fn.apply(obj2)  //打印结果都为obj2
1:硬绑定：bind，它会返回一个被编码的新函数，会把传入的this指定上下文并调用原始函数
注意：bind之后this就无法再改变
function fn(){
  console.log(this)
}
const obj1={}
const obj2={}
fn.bind(obj1).bind(obj2)()  // obj1
2:API调用指定上下文:在许多js内置函数中，都提供了一个可选参数，被称为‘上下文’，作用和bind一样，来指定回调函数中的this
function callback(){
  console.log(this)  //obj
}
const obj={}
[1,2,3].forEach(callback,obj)
```

4.  new绑定

   在js中，构造函数只是使用new操作符时被调用的函数。它们并不会属于某个类，甚至不会去实例化一个类，它们只是在被new时调用的一个普通函数。  

   使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作

   1.  创建一个全新的对象
   2. 这个新对象会被执行[[prototype]]链接
   3. 这个新对象会被绑定到函数调用的this
   4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这歌新对象

```js
const MyClass=new Class()
//过程
function new(target,...arg){
    const obj={}
    const self=target;
    obj.__proto__=target.prototype
    const isObj=self.call(obj,...arg)
    return typeof(isObj)==='object'?isObj:obj;
  
}
```

**绑定优先级**

显示绑定和和new绑定优先级肯定是大于隐式绑定的，但是显示绑定和new绑定那个优先级更高呢？  

被call和apply绑定的函数不能被new调用，但是可以通过bind来进行new调用。

```js
function Fn(a){
  this.a=a
}
const obj={}
const f=Fn.bind(obj)
f(2)
const f1=new f(3)
console.log(obj) //{a:2}
console.log(f1) //f1 {a:3}
```

f被硬绑定到obj上，但是new f(3)并没有把obj中的a改为3，，相反，new修改了绑定到obj上调用f中的this，并创建了一个新对象。  

来实现一下bind。

```js
function mybind(oThis){
  if(typeof(this)!=='function'){
    throw new TypeError(...)
  }
  const arg=Array.prototype.slice.call(arguments,1)
  const fToBind=this
  const fNOP=function(){}
  const fBound=function(){
    return fToBind.apply(
    (
    	this instanceof fNOP && oThis?this:oThis
    ),
      arg.concat(Array.prototype.slice.call(arguments))
    )
  }
  fNOP.prototype=this.prototype
  fBound.prototype=new fNOP()
  return fBound;
}
```

**判断this**

可以根据以下优先级进行判断   

1. 判断函数是否被new调用，如果是的话this指向新创建的对象
2. 判断函数是否通过显示绑定或者硬绑定(call、apply、bind)，是的话this指向绑定的对象
3. 判断函数是否在某个上下文调用(隐式绑定)，是的话this指向的是那个上下文对象
4. 都不是则遵循默认绑定原则。严格模式指向undefined，非严格模式指向全局对象。



**基本类型**

+ string

+ number

+ boolean

+ null

+ undefined

+ object

+ symbol （es6新增）   

   ⚠️：有时null会被当作一个对象，是js的一个bug。不同的对象在底层表示都是二进制，js中二进制前三位都为0会被认为是一个对象，但null二进制表示全为0，所以typeof会反回object。

**内置对象（对象子类型）**
+ String
+ Number
+ Boolean
+ Object
+ Function
+ Array
+ Date
+ Regexp
+ Error
```js
const str1=new String('abc')
const str2='abc'
console.log(str1.length,str2.length) //3 3
```
字符串子面量形式访问属性或者方法，内部对其做了转换，将字面量字符串转换成了对象字符串。其中对于数字和布尔值亦是如此。
null和undefined没有构造函数形式，只有文字形式。Date只有构造函数形式，没有文字形式。
对Object、Array、Function和RegExp，无论使用字面量还是构造函数形式，它们都是对象，没有文字形式。  

对象的内容是由一些储存在特定命名位置的（任意类型）的值组成，但这些值并不会储存在对象内部，对象内部储存的是这些值的名称，它们就像是指针（引用）一样，指向这些值真正储存的位置
对于对象来说，访问其中的值需要使用.操作符或者[]操作符，其中.属于属性访问，[]属于值访问
```js
const obj={
  a:1
}
obj.a  // 1
obj['a']  // 1
```
在对象中，属性名永远是字符串，如果使用除string类型之外的其他值作为属性名，它首先会被转化为字符串
```js
const obj={}
obj[true]=1
obj[3]=2
```


  


